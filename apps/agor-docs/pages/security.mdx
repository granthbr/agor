---
title: Security
description: Practical guidance for operating Agor safely while the product is still pre-1.0.
---

# Security

> **Agor is still pre-1.0.** Treat the daemon like an internal developer service, but note that the runtime now enforces authentication, role-aware authorization, and safer defaults.

## What’s Enforced Today

- All REST and Socket.io calls require authentication. Anonymous access (when enabled) is downgraded to a read-only `viewer` role.
- Privileged endpoints—terminals, environment start/stop, config edits, MCP wiring—require `admin` permissions. Session/task mutations require at least `member` permissions.
- File browsing is restricted to `context/` within each worktree, with path traversal guards in place.
- WebSocket broadcasts only reach authenticated clients; unauthenticated sockets no longer receive canvas or task events.
- Formal penetration testing has not been completed yet. Keep the daemon inside network boundaries you control.

## Access Model & Invitations

- Users authenticate with JWTs generated by the daemon. Roles (`viewer`, `member`, `admin`, `owner`) control which endpoints they can touch.
- Anonymous mode (if you explicitly enable it) maps to a read-only `viewer` role—no session creation, terminals, or environment controls.
- Terminal access and environment orchestration still run as the daemon’s underlying system user. Keep the daemon account scoped to the worktree directory and `/tmp` when possible.
- API keys for Claude/Codex/Gemini remain shared at the daemon level until per-user keys ship.

**What that means in practice:**

- Only invite collaborators you trust; every authenticated user inherits terminal access that executes commands as the daemon’s host user, so a compromised account effectively gains shell access to the machine.
- Prefer sandboxed VMs or disposable environments for multiplayer access.
- Run the daemon as a dedicated Unix user scoped to the Agor directories. Keep SSH/root access separate from day-to-day collaboration.

## Deployment Guidance

- Keep the daemon behind a firewall, VPN, or private network. Pair it with reverse proxies if you need SSO or IP allowlists.
- Harden the host like any shared dev box: patch regularly, monitor logs, and rotate credentials.
- If internet exposure is unavoidable, prefer open-source projects only and rotate API keys frequently.

## API Keys & Secrets

- Agent API keys configured in the daemon remain visible to `admin` users (and potentially compromised hosts). Load only what you need, monitor usage, and rotate aggressively.
- Prefer scoped or temporary credentials and keep secrets out of repositories.
- Consider de-elevating the daemon user further (e.g., dedicated VM + short-lived keys) when handling sensitive code.

### Encryption master secret

Agor encrypts stored credentials (Claude/Codex/Gemini API keys, MCP tokens, etc.) when the daemon starts with a master secret. Set the `AGOR_MASTER_SECRET` environment variable **before launching** `agor daemon start`.

- Generate a strong value (32+ random bytes). Example: `openssl rand -hex 32`.
- Export it in your shell or process manager:

```bash
# ~/.bashrc, ~/.zshrc, or systemd Environment directive
export AGOR_MASTER_SECRET="$(openssl rand -hex 32)"
```

- On Windows PowerShell:

```powershell
$env:AGOR_MASTER_SECRET = [System.Convert]::ToHexString((1..32 | ForEach-Object { Get-Random -Maximum 256 }))
agor daemon start
```

If the variable is missing, Agor falls back to **plaintext** storage and logs a warning at startup. Production and shared environments should always supply `AGOR_MASTER_SECRET`.

### Per-user secrets & trust boundaries

![Edit user settings modal showing agent API keys and environment variables per user](/screenshots/edit_user.png)

- **Per-user API keys** and environment variables live in each user’s profile (Settings → User). They are encrypted at rest with the master secret and only surface in the UI during entry.
- Despite encryption, the daemon still hosts all secrets; a malicious admin (or compromised host) could recover them. Invite only collaborators you trust with your tool credentials.
- Application admins can rotate or revoke keys quickly. Encourage teammates to manage their own secrets instead of sharing tenant-wide tokens.

## Codespaces Notes

- GitHub Codespaces only forwards ports to the Codespace owner by default, which helps when you're the only user.
- The moment you open those ports publicly, treat the environment as compromised: API keys, repository contents, and in-progress work can leak.
- Combine Codespaces with the guidance above—keep it behind authentication, and prefer non-sensitive workloads if you need to collaborate in a Codespace.

## Coming Soon

- **In-daemon OS-level impersonation** so operations run as the intended collaborator. See our [Unix User Integration exploration](https://github.com/mistercrunch/agor/blob/main/context/explorations/unix-user-integration.md) for the technical design and security implications of per-user Unix accounts, credential isolation, and sudo-based impersonation.
- Role-based access controls to scope who can see or modify specific worktrees, sessions, and resources.

Stay tuned for updates as these safeguards land. Until then, operate Agor with the same caution you would any powerful internal tool.
